# Tips

- [Tips](#tips)
  - [\[c++\] ë¬¸ìì—´ íŒŒì‹± ë°©ë²•](#c-ë¬¸ìì—´-íŒŒì‹±-ë°©ë²•)
  - [\[git\] submoduleì´ë€? submoduleì˜ merge request ì ˆì°¨ëŠ”?](#git-submoduleì´ë€-submoduleì˜-merge-request-ì ˆì°¨ëŠ”)
  - [\[linux\] tcpreplay ì‚¬ìš© ì‹œ, unable to send packet: message too long ë©”ì‹œì§€ê°€ ë°œìƒí•  ë•Œ í•´ê²° ë°©ë²•](#linux-tcpreplay-ì‚¬ìš©-ì‹œ-unable-to-send-packet-message-too-long-ë©”ì‹œì§€ê°€-ë°œìƒí• -ë•Œ-í•´ê²°-ë°©ë²•)
  - [\[linux\] tmux ì‚¬ìš© ë°©ë²• ì •ë¦¬](#linux-tmux-ì‚¬ìš©-ë°©ë²•-ì •ë¦¬)
  - [\[word\] ì§‘ìš”í•¨ì´ ê²°ê³¼ë¥¼ ë§Œë“¤ì–´ë‚¸ë‹¤.](#word-ì§‘ìš”í•¨ì´-ê²°ê³¼ë¥¼-ë§Œë“¤ì–´ë‚¸ë‹¤)
  - [\[linux\] rpmê³¼ yum](#linux-rpmê³¼-yum)
  - [\[linux\] google/sanitizes ë¥¼ ì´ìš©í•œ ë™ì  ë©”ëª¨ë¦¬ ì—ëŸ¬ ì·¨ì•½ì  ë°©ì–´](#linux-googlesanitizes-ë¥¼-ì´ìš©í•œ-ë™ì -ë©”ëª¨ë¦¬-ì—ëŸ¬-ì·¨ì•½ì -ë°©ì–´)
  - [\[c++\] boost::make\_iterator\_range()ë¥¼ í™œìš©í•˜ì—¬ range ê°ì²´í™”í•˜ê¸°](#c-boostmake_iterator_rangeë¥¼-í™œìš©í•˜ì—¬-range-ê°ì²´í™”í•˜ê¸°)
  - [\[c++\] í…œí”Œë¦¿ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•  ë•Œ ì„ ì–¸ë¶€ì™€ êµ¬í˜„ë¶€ë¥¼ ì„œë¡œ ë‹¤ë¥¸ íŒŒì¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ë°©ë²•](#c-í…œí”Œë¦¿-í´ë˜ìŠ¤ë¥¼-ì •ì˜í• -ë•Œ-ì„ ì–¸ë¶€ì™€-êµ¬í˜„ë¶€ë¥¼-ì„œë¡œ-ë‹¤ë¥¸-íŒŒì¼ë¡œ-ë¶„ë¦¬í•˜ëŠ”-ë°©ë²•)
  - [\[c++\] ODR(One Definition Rule)ì´ë€?](#c-odrone-definition-ruleì´ë€)
  - [\[c++\] asyncì˜ ì½œë°± í•¨ìˆ˜ë¡œ í´ë˜ìŠ¤ì˜ ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ì£¼ì˜ ì‚¬í•­](#c-asyncì˜-ì½œë°±-í•¨ìˆ˜ë¡œ-í´ë˜ìŠ¤ì˜-ë©¤ë²„-í•¨ìˆ˜ë¥¼-ì‚¬ìš©í•˜ëŠ”-ê²½ìš°-ì£¼ì˜-ì‚¬í•­)
  - [\[c++\] dynamic cast ì‚¬ìš© ì‹œ ì£¼ì˜ ì‚¬í•­](#c-dynamic-cast-ì‚¬ìš©-ì‹œ-ì£¼ì˜-ì‚¬í•­)
  - [\[c++\] ë¦¬íŒ©í† ë§ í›„ê¸°](#c-ë¦¬íŒ©í† ë§-í›„ê¸°)
  - [\[c++\] í´ë˜ìŠ¤ ì „ë°© ì„ ì–¸ ì™„ë²½ ì •ë¦¬](#c-í´ë˜ìŠ¤-ì „ë°©-ì„ ì–¸-ì™„ë²½-ì •ë¦¬)
  - [\[git\] git commit ë©”ì‹œì§€ì— í…œí”Œë¦¿ ì ìš©í•˜ëŠ” ë°©ë²•](#git-git-commit-ë©”ì‹œì§€ì—-í…œí”Œë¦¿-ì ìš©í•˜ëŠ”-ë°©ë²•)
  - [\[ë„¤íŠ¸ì›Œí¬\] tcpdumpë¡œ ì‹¤ì‹œê°„ íŒ¨í‚· íë¦„ í™•ì¸í•˜ê¸°](#ë„¤íŠ¸ì›Œí¬-tcpdumpë¡œ-ì‹¤ì‹œê°„-íŒ¨í‚·-íë¦„-í™•ì¸í•˜ê¸°)
  - [\[linux\] ì‚¬ì„¤ì¸ì¦ì„œ ë§Œë“¤ê¸°(ì„œë²„, í´ë¼ì´ì–¸íŠ¸)](#linux-ì‚¬ì„¤ì¸ì¦ì„œ-ë§Œë“¤ê¸°ì„œë²„-í´ë¼ì´ì–¸íŠ¸)

<br>

## [c++] ë¬¸ìì—´ íŒŒì‹± ë°©ë²•
ì „ì²´ ë¬¸ìì—´ ì¤‘ ì¼ë¶€ê°€ target ë¬¸ìì—´ì— ë§¤ì¹­ë˜ëŠ”ì§€ ì—¬ë¶€ë¥¼ í™•ì¸í•˜ê¸° ìœ„í•œ ê³¼ì • ì¤‘ì— ì¶”ì¶œëœ ë¶€ë¶„ ë¬¸ìì—´ì— ëŒ€í•˜ì—¬ openssl ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ì œê³µí•˜ëŠ” MD5 í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼í•˜ëŠ” ì‘ì—…ì´ í•„ìš”í–ˆìŠµë‹ˆë‹¤. ì•„ë˜ [MD5 í•¨ìˆ˜ì˜ ì •ì˜](https://www.openssl.org/docs/man1.1.1/man3/MD5.html)ë¥¼ ì‚´í´ë³´ë©´ md5 message digestë¥¼ ìƒì„±í•  ëŒ€ìƒì˜ ì‹œì‘ ì§€ì ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°(d)ì™€ í•´ë‹¹ ì‹œì‘ ì§€ì ì—ì„œë¶€í„° ì–¼ë§ˆë‚˜ ë–¨ì–´ì ¸ ìˆëŠ”ì§€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” ê¸¸ì´(n), ê·¸ë¦¬ê³  ìƒì„±ëœ md5 message digestë¥¼ ì €ì¥í•  ê³µê°„ì„ ê°€ë¦¬í‚¤ëŠ” í¬ì¸í„°(md)ë¥¼ í•¨ìˆ˜ì˜ ì¸ìë¡œ ë°›ê³ ìˆëŠ” ê²ƒì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```cpp
// MD5 message digest of the n bytes at d and place it in md
unsigned char *MD5(const unsigned char *d, unsigned long n, unsigned char *md);
```

ì´ì²˜ëŸ¼ ì›ë³¸ ë¬¸ìì—´ì„ ë³€í˜•ì‹œí‚¤ê±°ë‚˜ ë¶€ë¶„ ë¬¸ìì—´ì„ ìœ„í•œ ì„ì‹œ ê³µê°„ì„ ìƒì„±í•˜ì§€ ì•Šìœ¼ë©´ì„œ íŒŒì‹±í•˜ëŠ” ë°©ë²•ì´ ìˆë‹¤ëŠ” ê²ƒì„ ê¸°ì–µí•´ ë‘ë©´ ìœ ìš©í•  ê²ƒì…ë‹ˆë‹¤.

<br>

## [git] submoduleì´ë€? submoduleì˜ merge request ì ˆì°¨ëŠ”?
[git ê³µì‹ í™ˆí˜ì´ì§€](https://git-scm.com/docs/gitsubmodules)ì—ì„œëŠ” submoduleì„ ì•„ë˜ì™€ ê°™ì´ ì„¤ëª…í•˜ê³  ìˆìŠµë‹ˆë‹¤.
submoduleì€ ë‹¤ë¥¸ ì €ì¥ì†Œì•ˆì— ë‚´ì¥ëœ ì €ì¥ì†Œì…ë‹ˆë‹¤. submoduleì€ ìì²´ì ì¸ ë³€ê²½ ì´ë ¥ì„ ê°€ì§€ê³  ìˆê³ , submoduleì´ í¬í•¨ëœ ì €ì¥ì†Œë¥¼ superprojectë¼ê³  í•©ë‹ˆë‹¤.
> A submodule is a repository embedded inside another repository. The submodule has its own history; the repository it is embedded in is called a superproject.

submoduleì„ í¬í•¨í•˜ëŠ” í”„ë¡œì íŠ¸ì—ì„œ submoduleì„ ìˆ˜ì •í•´ì•¼ í•  ì¼ì´ ìƒê²¼ë‹¤ë©´..? ìˆ˜ì •ì„ ì™„ë£Œí•œ ë’¤ merge ìš”ì²­ì€ ìˆ˜ì •í•œ submoduleë¶€í„° mergeë¥¼ ì™„ë£Œí•˜ê³  ë‚œ ë’¤ì— í•´ë‹¹ submoduleì„ í¬í•¨í•˜ê³  ìˆëŠ” í”„ë¡œì íŠ¸ì— merge ìš”ì²­ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ì´ë•Œ í•´ë‹¹ í”„ë¡œì íŠ¸ì˜ ìˆ˜ì • ì‚¬í•­ì´ submoduleë¿ì´ë¼ë©´ ìˆ˜ì •í•œ submoduleì˜ commit ì •ë³´ë§Œ ë³€ê²½ ì‚¬í•­ìœ¼ë¡œ ì¡í ê²ƒì…ë‹ˆë‹¤.

<br>

## [linux] tcpreplay ì‚¬ìš© ì‹œ, unable to send packet: message too long ë©”ì‹œì§€ê°€ ë°œìƒí•  ë•Œ í•´ê²° ë°©ë²•
tcpreplayë¼ëŠ” íˆ´ì„ ì‚¬ìš©í•˜ì—¬ ì§€ì •ëœ nicì— íŠ¹ì • íŒ¨í‚·ì„ í˜ë ¤ë³´ë‚´ê³ ì í•  ë•Œ, message too longì´ë¼ëŠ” ì—ëŸ¬ ë©”ì‹œì§€ê°€ ë°œìƒí•˜ëŠ” ê²½ìš°ì—ëŠ” MTU(Maximum Transmission Unit) ì‚¬ì´ì¦ˆë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒì´ í•´ê²°ì±…ì´ ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
```
sudo ifconfig eth0 mtu 2000
```

<br>

## [linux] tmux ì‚¬ìš© ë°©ë²• ì •ë¦¬
ë¸”ë¡œê·¸ ê²Œì‹œê¸€ ì°¸ì¡°
* https://chelseafandev.github.io/2021/07/22/tip-how-to-use-tmux-md/

<br>

## [word] ì§‘ìš”í•¨ì´ ê²°ê³¼ë¥¼ ë§Œë“¤ì–´ë‚¸ë‹¤.
ì§‘ìš”í•˜ê²Œ íŒŒê³  ë“¤ì–´ì„œ ìƒê°í•˜ë‹¤ë³´ë©´ ì¢‹ì€ ê²°ê³¼ë¥¼ ë„ì¶œí•´ë‚¼ ë•Œê°€ ë§ë‹¤. ê³„ì†í•´ì„œ ì™œ(Why)ë¥¼ ìƒê°í•˜ë©´ì„œ í•˜ë‚˜ì”© íŒŒê³  ë“¤ì–´ë³´ì. ì§‘ìš”í•˜ê²Œ ë°˜ë³µí•˜ëŠ” ì™œ(Why)ë¥¼ í†µí•´ì„œ ê²°ê³¼ê°€ ë„ì¶œëœ ê³¼ì •ì´ ë³´ì¸ë‹¤.

<br>

## [linux] rpmê³¼ yum
* rpm: .rpm íŒŒì¼ì„ ì‚¬ìš©í•˜ì—¬ ì§ì ‘ íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•˜ê¸° ìœ„í•œ ëª…ë ¹ì–´ì…ë‹ˆë‹¤. ì˜ì¡´ì„±ì„ ê°–ëŠ” íŒ¨í‚¤ì§€ì˜ ê²½ìš°ì—ëŠ” ì˜ì¡´ ê´€ê³„ì— ë§ê²Œ ìˆœì„œëŒ€ë¡œ íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•´ì•¼í•˜ëŠ” ë²ˆê±°ë¡œì›€ì´ ìˆìŠµë‹ˆë‹¤.
* yum: yumì€ ê¸°ë³¸ì ìœ¼ë¡œ yum repositoryë¡œ ì§€ì •ëœ ì €ì¥ì†Œì— ì ‘ê·¼í•˜ì—¬ ì›í•˜ëŠ” íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•  ìˆ˜ ìˆë„ë¡ í•´ì£¼ëŠ” ëª…ë ¹ì–´ ì…ë‹ˆë‹¤. ì˜ì¡´ íŒ¨í‚¤ì§€ê¹Œì§€ ìë™ìœ¼ë¡œ ì„¤ì¹˜í•´ì£¼ê¸° ë•Œë¬¸ì— ë§¤ìš° í¸ë¦¬í•©ë‹ˆë‹¤.
* yum repository: rpmë“¤ì´ ë³´ê´€ë˜ëŠ” ì €ì¥ì†Œì…ë‹ˆë‹¤. yumì„ í†µí•œ íŒ¨í‚¤ì§€ ì„¤ì¹˜ëŠ” ì´ ì €ì¥ì†Œì— ì €ì¥ëœ rpmì„ ê¸°ì¤€ìœ¼ë¡œ ìˆ˜í–‰ë©ë‹ˆë‹¤.
  * RPMS/ : ë°”ì´ë„ˆë¦¬ RPMì—ëŠ” ì†ŒìŠ¤ ë° íŒ¨ì¹˜ì—ì„œ ë¹Œë“œëœ ë°”ì´ë„ˆë¦¬ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
  * SRPMS/ : SRPMì—ëŠ” ì†ŒìŠ¤ ì½”ë“œì™€ SPEC íŒŒì¼ì´ í¬í•¨ë˜ì–´ ìˆìœ¼ë©°, ë°”ì´ë„ˆë¦¬ RPMì— ì†ŒìŠ¤ ì½”ë“œë¥¼ ë¹Œë“œí•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤. ì„ íƒì ìœ¼ë¡œ ì†ŒìŠ¤ ì½”ë“œì— ëŒ€í•œ íŒ¨ì¹˜ë„ í¬í•¨ë©ë‹ˆë‹¤.
  * repodata/ : repositoryì— ëŒ€í•œ meta ë°ì´í„°ë“¤ì´ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
  * RPM-GPG-KEY : ì œê³µí•˜ëŠ” íŒ¨í‚¤ì§€ì— ëŒ€í•œ ìœ íš¨ì„± ê²€ì¦ì„ ìœ„í•´ ì‚¬ìš©ë˜ëŠ” ê³µê°œí‚¤ ì •ë³´ì…ë‹ˆë‹¤.

RPMS/ ë””ë ‰í† ë¦¬ì— ì¡´ì¬í•˜ëŠ” rpmë“¤ì„ yumì„ í†µí•´ ì„¤ì¹˜í•˜ëŠ” ê²½ìš°ì—ëŠ” rpm íŒŒì¼ëª…ì—ì„œ í•´ë‹¹ íŒ¨í‚¤ì§€ì˜ ë²„ì „ ì •ë³´ ì´ì „ê¹Œì§€ì˜ ëª…ì¹­ì„ ì‚¬ìš©í•˜ë©´ ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, rpm íŒŒì¼ëª…ì´ `nodejs-6.14.3-1.el7.x86_64.rpm`ì´ë¼ê³  í•œë‹¤ë©´ ì„¤ì¹˜ ëª…ë ¹ì–´ëŠ” ì•„ë˜ì™€ ê°™ìŠµë‹ˆë‹¤.
```
yum install nodejs
```

(ì°¸ê³ ì‚¬í•­1) `el7`ì˜ ì˜ë¯¸ëŠ”?
**EL** is short for Red Hat **E**nterprise **L**inux (EL).
* EL6 is the download for Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x.
* EL5 is the download for Red Hat 5.x, CentOS 5.x, CloudLinux 5.x.
* EL7 is the download for Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x.

(ì°¸ê³ ì‚¬í•­2) `x86_64`ì˜ ì˜ë¯¸ëŠ”?
ì•„í‚¤í…ì³ ì¢…ë¥˜ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.

Red Hat ê³µì‹ í™ˆí˜ì´ì§€ì—ì„œ [RPM íŒ¨í‚¤ì§• ê°€ì´ë“œ](https://access.redhat.com/documentation/ko-kr/red_hat_enterprise_linux/7/html/rpm_packaging_guide/index)ë¬¸ì„œë¥¼ ì œê³µí•˜ê³  ìˆìœ¼ë‹ˆ ì°¸ê³ ë°”ëë‹ˆë‹¤.

<br>

## [linux] google/sanitizes ë¥¼ ì´ìš©í•œ ë™ì  ë©”ëª¨ë¦¬ ì—ëŸ¬ ì·¨ì•½ì  ë°©ì–´
ì–´ë–¤ ë°©ì‹ìœ¼ë¡œ ë©”ëª¨ë¦¬ ì·¨ì•½ì ì„ ë™ì ìœ¼ë¡œ ì ê²€í•  ìˆ˜ ìˆì„ê¹Œì— ëŒ€í•œ ê¶ê¸ˆì¦ì„ í•´ì†Œí•˜ê¸° ìœ„í•´ [ê³µì‹ Wiki](https://github.com/google/sanitizers/wiki)ë¥¼ ì‚´í´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

<br>

## [c++] boost::make_iterator_range()ë¥¼ í™œìš©í•˜ì—¬ range ê°ì²´í™”í•˜ê¸°
boost::iterator_range() í•¨ìˆ˜ëŠ” beginê³¼ end iteratorë¡œë¶€í„° range ê°ì²´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. range ê°ì²´ëŠ” ëŒ€ê²Œ begin()ê³¼ end()ë¥¼ ë©”ì†Œë“œ í•¨ìˆ˜ë¡œ ê°–ëŠ” containerë¡œë¶€í„° ìƒì„±ë˜ê¸° ë•Œë¬¸ì— boost::iterator_range() í•¨ìˆ˜ëŠ” ì‚¬ìš©ì ì •ì˜ iteratorë¥¼ ë˜í•‘(wrapping)í•˜ëŠ”ë° ìœ ìš©í•˜ê²Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
> iterator_range() creates a range object from a begin and end iterator. Since ranges are constructed implicitly from containers that have .begin() and .end() methods, it's mostly useful for wrapping custom iterators.

ì‹¤ì œë¡œëŠ” template íƒ€ì…ì„ ìë™ìœ¼ë¡œ ì¶”ë¡ (deduce)í•´ì£¼ëŠ” boost::make_iterator_range() í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì¡°ê¸ˆ ë” í¸ë¦¬í•©ë‹ˆë‹¤.
> In practice, it's more convenient to use the make_iterator_range() function that deduces the template type automatically.

```cpp
#include <iostream>
#include <iterator>
#include <sstream>

#include <boost/range.hpp>

int main()
{
    std::stringstream ss("The quick brown fox jumps over the lazy dog.");
    auto begin = std::istream_iterator<std::string>(ss);
    auto end = std::istream_iterator<std::string>();

    // iterator_range
    auto range = boost::iterator_range<decltype(begin)>(begin, end);
    for (const auto & word : range) {
        std::cout << "[" << word << "] ";
    }
    std::cout << std::endl;

    // make_iterator_range í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ì—ëŠ” template typeì„ ìë™ìœ¼ë¡œ ì¶”ë¡ (deduce)í•´ì¤€ë‹¤.
    for (const auto & word : boost::make_iterator_range(begin, end)) {
        std::cout << "[" << word << "] ";
    }
    std::cout << std::endl;

    return 0;
}
```
```
[The] [quick] [brown] [fox] [jumps] [over] [the] [lazy] [dog.] 
[The] [quick] [brown] [fox] [jumps] [over] [the] [lazy] [dog.]
```

<br>

## [c++] í…œí”Œë¦¿ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•  ë•Œ ì„ ì–¸ë¶€ì™€ êµ¬í˜„ë¶€ë¥¼ ì„œë¡œ ë‹¤ë¥¸ íŒŒì¼ë¡œ ë¶„ë¦¬í•˜ëŠ” ë°©ë²•
í—¤ë” íŒŒì¼ì˜ ë§¨ í•˜ë‹¨ì— í…œí”Œë¦¿ í´ë˜ìŠ¤ë¥¼ êµ¬í˜„í•œ íŒŒì¼ì„ include ì‹œì¼œì£¼ë©´ ëœë‹¤. (#includeëŠ” ëŒ€ìƒì´ë˜ëŠ” íŒŒì¼ì„ ë‹¨ìˆœíˆ ë¶™ì—¬ ë„£ì–´ì£¼ëŠ” ì—­í• ì„ í•˜ë¯€ë¡œ)
```cpp
#ifndef MYTEMPLATECLASS_H
#define MYTEMPLATECLASS_H

namespace ggultip
{
	template <typename T>
	class mytemplateclass
	{
	public:
		mytemplateclass();
		~mytemplateclass();
		
		...
	};
}

#endif

#include "mytemplateclass.impl.h"
```

```cpp
#pragma once

namespace ggultip
{
	template <typename T>
	mytemplateclass<T>::mytemplateclass()
	{
		...
	}
	
	template <typename T>
	mytemplateclass<T>::~mytemplateclass()
	{
		...
	}
	
	...
}
```

<br>

## [c++] ODR(One Definition Rule)ì´ë€?
* https://learn.microsoft.com/en-us/cpp/cpp/program-and-linkage-cpp?view=msvc-170
* https://modoocode.com/320

C++ í”„ë¡œê·¸ë¨ì—ì„œ ë³€ìˆ˜ë‚˜ í•¨ìˆ˜ì˜ ì´ë¦„ì™€ ê°™ì€ ì‹¬ë³¼ì€ ê·¸ê²ƒë“¤ì˜ ìƒëª… ì£¼ê¸°ê°€ ìœ ì§€ë˜ëŠ” ë²”ìœ„ ë‚´ì—ì„œëŠ” íšŸìˆ˜ì— ê´€ê³„ì—†ì´ ì„ ì–¸(declaration)ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ì˜¤ì§ í•œë²ˆë§Œ ì •ì˜(definition) ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê·œì¹™ì´ ë°”ë¡œ "One Definition Rule(ODR)"ì…ë‹ˆë‹¤.
> In a C++ program, a symbol, for example a variable or function name, can be declared any number of times within its scope. However, it can only be defined once. This rule is the "One Definition Rule" (ODR).

í”„ë¡œê·¸ë¨ì€ í•˜ë‚˜ ë˜ëŠ” ê·¸ ì´ìƒì˜ í•´ì„ ìœ ë‹›(Translation Unit)ìœ¼ë¡œ êµ¬ì„±ë˜ì–´ìˆìŠµë‹ˆë‹¤. í•´ì„ ìœ ë‹›ì€ êµ¬í˜„ íŒŒì¼ê³¼ ê·¸ê²ƒì— ì§/ê°„ì ‘ì ìœ¼ë¡œ í¬í•¨ëœ ëª¨ë“  í—¤ë” íŒŒì¼ë“¤ë¡œ ì´ë£¨ì–´ì ¸ìˆìŠµë‹ˆë‹¤. ë³´í†µ êµ¬í˜„ íŒŒì¼ë“¤ì€ .cppë‚˜ .cxxì™€ ê°™ì€ íŒŒì¼ í™•ì¥ìë¥¼ ê°–ìŠµë‹ˆë‹¤. í—¤ë” íŒŒì¼ì˜ ê²½ìš°ì—ëŠ” .h ë˜ëŠ” .hppë¥¼ íŒŒì¼ í™•ì¥ìë¡œ ê°–ìŠµë‹ˆë‹¤. ê°ê°ì˜ í•´ì„ ìœ ë‹›ì€ ì»´íŒŒì¼ëŸ¬ì— ì˜í•´ ë…ë¦½ì ìœ¼ë¡œ ì»´íŒŒì¼ë©ë‹ˆë‹¤. ì»´íŒŒì¼ì´ ì™„ë£Œëœ ì´í›„ì—, ë§ì»¤ëŠ” ì»´íŒŒì¼ëœ í•´ì„ ìœ ë‹›ë“¤ì„ í•˜ë‚˜ì˜ í”„ë¡œê·¸ë¨ìœ¼ë¡œ í•©ì¹˜ëŠ” ì—­í• ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. ODR ê·œì¹™ì˜ ìœ„ë°˜ì€ ëŒ€ê²Œ ë§ì»¤ ì—ëŸ¬ë¡œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤. ì´ ë§ì»¤ ì—ëŸ¬ëŠ” ë™ì¼í•œ ì´ë¦„ì´ í•˜ë‚˜ ì´ìƒì˜ í•´ì„ ìœ ë‹›ì—ì„œ ì •ì˜(definition)ëœ ê²½ìš°ì— ë°œìƒí•©ë‹ˆë‹¤.
> A program consists of one or more translation units. A translation unit consists of an implementation file and all the headers that it includes directly or indirectly. Implementation files typically have a file extension of .cpp or .cxx. Header files typically have an extension of .h or .hpp. Each translation unit is compiled independently by the compiler. After the compilation is complete, the linker merges the compiled translation units into a single program. Violations of the ODR rule typically show up as linker errors. Linker errors occur when the same name is defined in more than one translation unit.

ê° TU ì— ì¡´ì¬í•˜ëŠ” ëª¨ë“  ë³€ìˆ˜, í•¨ìˆ˜, í´ë˜ìŠ¤, enum, í…œí”Œë¦¿ ë“±ë“±ì˜ ì •ì˜(Definition) ì€ ìœ ì¼ í•´ì•¼ í•˜ê³  `inline` ì´ ì•„ë‹Œ ëª¨ë“  í•¨ìˆ˜ì˜ ë³€ìˆ˜ë“¤ì˜ ì •ì˜ëŠ” ì „ì²´ í”„ë¡œê·¸ë¨ì—ì„œ ìœ ì¼í•´ì•¼ í•©ë‹ˆë‹¤.

<br>

## [c++] asyncì˜ ì½œë°± í•¨ìˆ˜ë¡œ í´ë˜ìŠ¤ì˜ ë©¤ë²„ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²½ìš° ì£¼ì˜ ì‚¬í•­
* https://stackoverflow.com/questions/57427740/how-to-pass-a-function-and-its-parameters-to-stdasync-inside-a-member-functio

std::async í•¨ìˆ˜ì˜ ì¸ìë¡œ ë°˜ë“œì‹œ `this`ë¥¼ í•¨ê»˜ ë„˜ê²¨ì£¼ì–´ì•¼ í•©ë‹ˆë‹¤.

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <future>

using namespace std;

class splitter
{
    public:
    splitter() = default;
    virtual ~splitter() = default;
    bool execute(vector<string> &vstr);
    bool split_files(vector<string> &vstr);
};

bool splitter::split_files(vector<string> &vstr)
{
    for(auto & file : vstr)
    {
        // do something
        cout << file << endl;
    }
    return true;
}

bool splitter::execute(vector<string> &vstr)
{
    // 3ë²ˆì§¸ ì¸ìë¡œ thisê°€ ë“¤ì–´ê°€ì•¼í•œë‹¤ëŠ” ê²ƒì— ì£¼ì˜ í•˜ì!
	auto fut = std::async(std::launch::async, &splitter::split_files, this, std::ref(vstr));
    bool good = fut.get();
    return good;
}

int main()
{
    vector<string> filenames {
                                "file1.txt",
                                "file2.txt",
                                "file3.txt"
                             };

    splitter split;
    split.execute(filenames);

    return 0;
}
```

<br>

## [c++] dynamic cast ì‚¬ìš© ì‹œ ì£¼ì˜ ì‚¬í•­
* https://www.geeksforgeeks.org/rtti-run-time-type-information-in-cpp/

dynamic casting ì´í›„ì—ëŠ” ë°˜ë“œì‹œ nullptr ì²´í¬ë¥¼ í•´ì£¼ì. ê·¸ë¦¬ê³  dynamic castì˜ ê²½ìš° ë¹„ìš©ì´ ê½¤ í¬ê¸°ë•Œë¬¸ì— static castë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ìƒí™©ì´ë¼ë©´ static castë¥¼ ìš°ì„  í•˜ì.

> Using `dynamic_cast`: In an inheritance hierarchy, it is used for downcasting a base class pointer to a child class. On successful casting, it returns a pointer of the converted type and, however, it fails if we try to cast an invalid type such as an object pointer that is not of the type of the desired subclass.

```cpp
#include <iostream>
using namespace std;
 
// initialization of base class
class B {};
 
// initialization of derived class
class D : public B {};
 
// Driver Code
int main()
{
    B* b = new D; // Base class pointer
    D* d = dynamic_cast<D*>(b); // Derived class pointer
    if (d != NULL)
        cout << "works";
    else
        cout << "cannot cast B* to D*";
    getchar(); // to get the next character
    return 0;
}
```

* *ì—…ìºìŠ¤íŒ…*ì€ static_cast
* *ë‹¤ìš´ìºìŠ¤íŒ…* dynamic_cast
```cpp
#include <iostream>

template <typename DerivedT>
class Base
{
public:
    Base()
    {
        
    }

    // ë°˜ë“œì‹œ ì¶”ê°€!
    virtual ~Base()
    {

    }

    DerivedT *derived()
    {
        // ë‹¤ìš´ìºìŠ¤íŒ…
        return static_cast<DerivedT *>(this);
    }

    void print_derived_info()
    {
        derived()->mark(); // ê¸°ë°˜í´ë˜ìŠ¤ì˜ ë©¤ë²„í•¨ìˆ˜ì—ì„œ íŒŒìƒí´ë˜ìŠ¤ì˜ public ë©¤ë²„í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤
        derived()->set_idx(100); // ê¸°ë°˜í´ë˜ìŠ¤ì˜ ë©¤ë²„í•¨ìˆ˜ì—ì„œ íŒŒìƒí´ë˜ìŠ¤ê°€ ìƒì†ë°›ëŠ” í´ë˜ìŠ¤ì˜ public ë©¤ë²„í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë‹¤.
    }
};

template <typename DerivedT>
class AnotherBase
{
public:
    AnotherBase()
    {
        idx_ = 0;
    }

    void set_idx(int new_idx)
    {
        idx_ = new_idx;
        std::cout << "call set_idx(idx: " << idx_ << ")" << std::endl;
    }

private:
    int idx_;
};

template <int kind, template <typename> typename DerivedT>
class Derived 
    : public Base<Derived<kind, DerivedT>>
    , public AnotherBase<Derived<kind, DerivedT>>
{
public:
    typedef Derived<kind, DerivedT> this_type;
	typedef DerivedT<this_type> derived_type;

    Derived(std::string msg)
    {
        mark_ = "i'm ";
        mark_ += msg;
        mark_ += " derived";
    }

    void call_test()
    {
        derived_type::print_derived_info();
    }

    void mark()
    {
        std::cout << mark_ << std::endl;
    }

private:
    std::string mark_;
};

int main()
{
    Derived<100, Base> derived("first");
    Derived<100, Base> derived2("second");

    derived.call_test();
    derived2.call_test();

    // ì—…ìºìŠ¤íŒ…
    Derived<100, Base>* d = new Derived<100, Base>("third");
    Base<Derived<100, Base>>* b = d;
    
    // ë‹¤ìš´ìºìŠ¤íŒ…(static_cast)
    Base<Derived<200, Base>>* b2 = new Derived<200, Base>("forth");
    Derived<200, Base>* d2;
    d2 = static_cast<Derived<200, Base>*>(b2);
    if(d2 != nullptr)
    {
        d2->mark();
    }
    
    // ë‹¤ìš´ìºìŠ¤íŒ…(dynamic_cast)
    Base<Derived<200, Base>>* b3 = new Derived<200, Base>("fifth");
    Derived<200, Base>* d3 = dynamic_cast<Derived<200, Base>*>(b3);
    if(d3 != nullptr)
    {
        d3->mark();
    }
    
    return 0;
}
```

<br>

## [c++] ë¦¬íŒ©í† ë§ í›„ê¸°
* ë¶ˆí•„ìš”í•œ ê°’ì˜ ë³µì‚¬ëŠ” í”¼í•˜ë¼(const & í™œìš©)
* í•¨ìˆ˜ë¥¼ í…œí”Œë¦¿ ì¸ìë¡œ ë°›ì•„ì„œ ì²˜ë¦¬í•˜ë„ë¡ í•˜ë¼(í…œí”Œë¦¿ ì¸ìë¡œ ì‚¬ìš©ë˜ëŠ” í•¨ìˆ˜ëŠ” ëŒë‹¤ë¡œ ì •ì˜)
* ì½”ë“œì˜ ì¤‘ë³µì„ ìµœëŒ€í•œ í”¼í•˜ë¼(ì´ë¥¼ ìœ„í•´ í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ë“ , ë³„ë„ì˜ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë“  í•˜ì)
* forë¬¸ì€ range í˜•íƒœë¡œ ì‘ì„±í•˜ë©´ ê¹”ë”í•˜ë‹¤
* ë°˜ë³µë¬¸ì„ forë¬¸(rangeê¸°ë°˜ì´ ê¹”ë”)ê³¼ ëŒë‹¤ë¥¼ í™œìš©í•˜ë©´ ìœ ìš©í•˜ë‹¤(ë™ì¼í•œ í•¨ìˆ˜ì™€ ì…ë ¥ ê°’ì„ ì‚¬ìš©í•˜ì—¬ ì„œë¡œ ë‹¤ë¥¸ ë°˜ë³µ ì‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤.)
* lambda ë‚´ì—ì„œ í´ë˜ìŠ¤ì˜ ë©¤ë²„ ë³€ìˆ˜ì— ì ‘ê·¼í•˜ë ¤ë©´ thisë¥¼ ìº¡ì³í•˜ë¼([í•´ë‹¹ ë§í¬](https://stackoverflow.com/questions/30142730/c-lambda-capture-private-class-member) ì°¸ì¡°)

```cpp
std::vector<int> container = {1, 2, 3, 4, 5};

template <typename ProcedureT>
bool loop_test(ProcedureT p)
{
	for (auto data : container)
	{
		if (p(data) == true)
		{
			return data;
		}
	}
}

// í˜¸ì¶œ ì‹œ
loop_test(
[](int data) -> bool {
	if(data == 3)
	{
		return true;
	}
	return false;
}
);
```

<br>

## [c++] í´ë˜ìŠ¤ ì „ë°© ì„ ì–¸ ì™„ë²½ ì •ë¦¬
* https://stackoverflow.com/questions/553682/when-can-i-use-a-forward-declaration

ì—¬ëŸ¬ë¶„ì´ ì»´íŒŒì¼ëŸ¬ì˜ ì…ì¥ì— ìˆë‹¤ê³  ìƒê°í•´ë´…ì‹œë‹¤: íƒ€ì…ì„ ì „ë°© ì„ ì–¸í•˜ëŠ” ê²½ìš° ì»´íŒŒì¼ëŸ¬ê°€ ì•Œê³ ìˆëŠ” ì „ë¶€ëŠ” ì´ íƒ€ì…ì´ ì¡´ì¬í•œë‹¤ëŠ” ê²ƒë¿ì…ë‹ˆë‹¤; ê·¸ê²ƒì˜ ì‚¬ì´ì¦ˆë‚˜ ë©¤ë²„ ë˜ëŠ” ë©”ì†Œë“œì— ê´€í•œ ê²ƒì€ ì „í˜€ ì•Œì§€ ëª»í•©ë‹ˆë‹¤. ì´ê²ƒì´ ë°”ë¡œ ë¶ˆì™„ì „í•œ íƒ€ì…(incomplete type)ì´ë¼ê³  ë¶ˆë¦¬ëŠ” ì´ìœ ì…ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ê°€ ì´ íƒ€ì…ì˜ ë ˆì´ì•„ì›ƒì„ ì•Œì•„ì•¼í•˜ê¸° ë•Œë¬¸ì—, ì—¬ëŸ¬ë¶„ì´ ì´ íƒ€ì…ì„ ë©¤ë²„ ë³€ìˆ˜ë¡œ ì„ ì–¸í•œë‹¤ê±°ë‚˜ í˜¹ì€ ë¶€ëª¨ í´ë˜ìŠ¤ë¡œ ì‚¬ìš©í•œë‹¤ê±°ë‚˜ í•˜ëŠ” ê²ƒì€ ë¶ˆê°€ëŠ¥í•©ë‹ˆë‹¤.
> Put yourself in the compiler's position: when you forward declare a type, all the compiler knows is that this type exists; it knows nothing about its size, members, or methods. This is why it's called anÂ *incomplete type*. Therefore, you cannot use the type to declare a member, or a base class, since the compiler would need to know the layout of the type.

ì•„ë˜ì™€ ê°™ì€ í´ë˜ìŠ¤ ì „ë°© ì„ ì–¸ì„ ê°€ì •í•´ë³´ê² ìŠµë‹ˆë‹¤.
> Assuming the following forward declaration.

ì—¬ê¸° ì—¬ëŸ¬ë¶„ì´ í•  ìˆ˜ ìˆëŠ”ê²ƒê³¼ í•  ìˆ˜ ì—†ëŠ” ê²ƒì´ ìˆìŠµë‹ˆë‹¤.
> Here's what you can and cannot do.

<br>

**What you can do with an incomplete type:**
* Declare a member to be a pointer or a reference to the incomplete type:
```cpp
class Foo {
		// ì „ë°© ì„ ì–¸í•œ í´ë˜ìŠ¤ íƒ€ì…ì˜ í¬ì¸í„°ë³€ìˆ˜ì™€ ë ˆí¼ëŸ°ìŠ¤ë³€ìˆ˜ëŠ” ì‚¬ìš©ì´ ê°€ëŠ¥í•¨
    X* p;
    X& r;
};
```

* DeclareÂ functions or methods which accept/return incomplete types:
```cpp
// í•¨ìˆ˜ë‚˜ ë©”ì†Œë“œì˜ ì¸ìì™€ ë°˜í™˜ ê°’ì—ë„ ì „ë°© ì„ ì–¸í•œ í´ë˜ìŠ¤ íƒ€ì…ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
void f1(X);
X f2();
```

* DefineÂ functions or methods which accept/return pointers/references to the incomplete type (but without using its members):
```cpp
// í•¨ìˆ˜ë‚˜ ë©”ì†Œë“œì˜ ì¸ìì™€ ë°˜í™˜ê°’ì— ì „ë°© ì„ ì–¸í•œ í´ë˜ìŠ¤ íƒ€ì…ì˜ í¬ì¸í„°ì™€ ë ˆí¼ëŸ°ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
// ë‹¨, ë¶ˆì™„ì „í•œ íƒ€ì…ì˜ ë©¤ë²„ ë³€ìˆ˜ ì ‘ê·¼ì´ë‚˜ ë©¤ë²„ í•¨ìˆ˜ì˜ í˜¸ì¶œì€ ë¶ˆê°€í•¨
void f3(X*, X&) {}
X& f4() {}
X* f5() {}
```

<br>

**What you cannot do with an incomplete type:**
* Use it as a base class
```cpp
// ë¶€ëª¨í´ë˜ìŠ¤ë¡œ ì‚¬ìš©ì´ ë¶ˆê°€í•¨
class Foo : public X // compiler error!
```

* Use it to declare a member:
```cpp
// (í¬ì¸í„°ë‚˜ ë ˆí¼ëŸ°ìŠ¤ê°€ ì•„ë‹Œ) ì „ë°© ì„ ì–¸í•œ í´ë˜ìŠ¤ íƒ€ì…ì„ ë©¤ë²„ ë³€ìˆ˜ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
class Foo {
    X m; // compiler error!
};
```

* DefineÂ functions or methods using this type
```cpp
// (í¬ì¸í„°ë‚˜ ë ˆí¼ëŸ°ìŠ¤ê°€ ì•„ë‹Œ) ì „ë°© ì„ ì–¸í•œ í´ë˜ìŠ¤ íƒ€ì…ì„ í•¨ìˆ˜ë‚˜ ë©”ì†Œë“œì— ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ
void f1(X x) {} // compiler error!
X f2() {} // compiler error!
```

* Use its methods or fields, in fact trying to dereference a variable with incomplete type
```cpp
// ë¶ˆì™„ì „í•œ íƒ€ì…ì˜ ë©¤ë²„ ë³€ìˆ˜ì˜ ì ‘ê·¼ì´ë‚˜ ë©¤ë²„ í•¨ìˆ˜ì˜ í˜¸ì¶œì€ ë¶ˆê°€í•¨
class Foo {
    X* m; // ok!
		
    void method()            
    {
        m->someMethod();      // compiler error!
        int i = m->someField; // compiler error!
    }
};
```

<br>

## [git] git commit ë©”ì‹œì§€ì— í…œí”Œë¦¿ ì ìš©í•˜ëŠ” ë°©ë²• 
```bash
$ touch ~/.gitmessage.txt
```

```bash
$ vim ~/.gitmessage.txt
```

```
##### ì œëª© - 50ì ì´ë‚´ë¡œ ìš”ì•½!

### [ì»¤ë°‹ íƒ€ì…]: [ì‘ì—…ë‚´ìš©]

##### ë³¸ë¬¸ - í•œ ì¤„ì— ìµœëŒ€ 72 ê¸€ìê¹Œì§€ë§Œ ì…ë ¥í•˜ê¸°

# 1. ë¬´ì—‡ì„ ìˆ˜ì •í–ˆëŠ”ì§€
# 2. ì™œ ìˆ˜ì •í–ˆëŠ”ì§€

# ê¼¬ë¦¿ë§ì€ ì•„ë˜ì— ì‘ì„±: ex) #ì´ìŠˆ ë²ˆí˜¸

#   [ì»¤ë°‹ íƒ€ì…]  ë¦¬ìŠ¤íŠ¸
#   feat      : ê¸°ëŠ¥ (ìƒˆë¡œìš´ ê¸°ëŠ¥)
#   fix       : ë²„ê·¸ (ë²„ê·¸ ìˆ˜ì •)
#   refactor  : ë¦¬íŒ©í† ë§
#   style     : ìŠ¤íƒ€ì¼ (ì½”ë“œ í˜•ì‹, ì„¸ë¯¸ì½œë¡  ì¶”ê°€: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ë³€ê²½ ì—†ìŒ)
#   docs      : ë¬¸ì„œ (ë¬¸ì„œ ì¶”ê°€, ìˆ˜ì •, ì‚­ì œ)
#   test      : í…ŒìŠ¤íŠ¸ (í…ŒìŠ¤íŠ¸ ì½”ë“œ ì¶”ê°€, ìˆ˜ì •, ì‚­ì œ: ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ë³€ê²½ ì—†ìŒ)
#   chore     : ê¸°íƒ€ ë³€ê²½ì‚¬í•­ (ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸ ìˆ˜ì • ë“±)
#   post      : ë¸”ë¡œê·¸ í¬ìŠ¤íŠ¸ ì¶”ê°€ (ì‹ ê·œ í¬ìŠ¤íŠ¸ ì‘ì„± ë° ìˆ˜ì •)
#   algo      : ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œ í’€ì´ ì¶”ê°€ (ì‹ ê·œ ë¬¸ì œ ì¶”ê°€ ë° ë¬¸ì œ í’€ì´ ì‘ì„±)
# ------------------
#   [ì²´í¬ë¦¬ìŠ¤íŠ¸]
#     ì œëª© ì²« ê¸€ìëŠ” ëŒ€ë¬¸ìë¡œ ì‘ì„±í–ˆë‚˜ìš”?
#     ì œëª©ì€ ëª…ë ¹ë¬¸ìœ¼ë¡œ ì‘ì„±í–ˆë‚˜ìš”?
#     ì œëª© ëì— ë§ˆì¹¨í‘œ(.) ê¸ˆì§€
#     ì œëª©ê³¼ ë³¸ë¬¸ì„ í•œ ì¤„ ë„ì›Œ ë¶„ë¦¬í•˜ê¸°
#     ë³¸ë¬¸ì— ì—¬ëŸ¬ì¤„ì˜ ë©”ì‹œì§€ë¥¼ ì‘ì„±í•  ë• "-"ë¡œ êµ¬ë¶„í–ˆë‚˜ìš”?
# ------------------
```

```bash
$ git config --global commit.template ~/.gitmessage.txt
```

<br>

## [ë„¤íŠ¸ì›Œí¬] tcpdumpë¡œ ì‹¤ì‹œê°„ íŒ¨í‚· íë¦„ í™•ì¸í•˜ê¸°
`eth0`ë¡œ ìœ ì…ë˜ëŠ” íŒ¨í‚· ì¤‘ `tcp`ì´ë©° port ë²ˆí˜¸ê°€ `5757`ì¸ íŒ¨í‚· íë¦„ í™•ì¸

```
tcpdump -nnS -vv -i eth0 tcp port 5757
```
* `nn`: í˜¸ìŠ¤íŠ¸/ì„œë¹„ìŠ¤ëª…ì´ ì•„ë‹Œ IPì£¼ì†Œì™€ Portë²ˆí˜¸ë¡œ ì¶œë ¥
* `S`: tcp ì‹œí€€ìŠ¤ ë²ˆí˜¸ì— ëŒ€í•´ ìƒëŒ€ì (relative) ë²ˆí˜¸ê°€ ì•„ë‹Œ ì ˆëŒ€ì (absolute) ë²ˆí˜¸ ì¶œë ¥
* `v, vv, vvv`: íŒ¨í‚·ì„ í—¤ë”ë¶€ê¹Œì§€ ìì„¸íˆ ì¶œë ¥

<br>

`[S]` : SYN

`[S.]` : SYN + ACK

`[.]` : ACK

`[P.]`: PUSH + ACK

`[F.]`: FIN + ACK
![](../resource/image/tcpdump_1.png)
![](../resource/image/tcpdump_2.png)

<br>

## [linux] ì‚¬ì„¤ì¸ì¦ì„œ ë§Œë“¤ê¸°(ì„œë²„, í´ë¼ì´ì–¸íŠ¸)

ì„œë²„ ë° í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ì„œ ì„¤ì •ì€ [í•´ë‹¹ ë§í¬](https://docs.jelastic.com/ssl-for-pgsql/)ì— ì„¤ëª…ì´ ì•„ì£¼ ì˜ë˜ì–´ìˆì–´ì„œ ë‚˜ì¤‘ì— ì°¸ê³ ë¥¼ ìœ„í•´ ë²ˆì—­ í•´ë³´ì•˜ë‹¤.

**1. PostgreSQL ì„œë²„ ì„¤ì •**

1.1. SSL í†µì‹ ì„ ìœ„í•´ì„œ ì„œë²„ì˜ /var/lib/pgsql/data ê²½ë¡œì— ì•„ë˜ 3ê°€ì§€ íŒŒì¼ì´ ì¶”ê°€ë˜ì–´ì•¼í•œë‹¤.
- server.key : ì„œë²„ ê°œì¸í‚¤
- server.crt : ì„œë²„ ì¸ì¦ì„œ
- root.crt : ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë£¨íŠ¸ ì¸ì¦ì„œ

1.2. ë¨¼ì €, ì²«ë²ˆì§¸ íŒŒì¼ì¸ - (ì„œë²„) ê°œì¸í‚¤ë¥¼ ì•„ë˜ ëª…ë ¹ì–´ë¥¼ í†µí•´ ìƒì„±í•´ë³´ì.
```bash
cd /var/lib/pgsql/data
openssl genrsa -des3 -out server.key 1024
```
```bash
openssl rsa -in server.key -out server.key
```

1.3. ì•„ë˜ ëª…ë ¹ì–´ë¥¼ í†µí•´ ìƒì„±ëœ (ì„œë²„)ê°œì¸ í‚¤ì˜ ì ì ˆí•œ ê¶Œí•œê³¼ ì†Œìœ ê¶Œì„ ì„¤ì •í•œë‹¤.
```bash
chmod 400 server.key
chown postgres.postgres server.key
```

1.4. ì´ì œ ì„œë²„ ê°œì¸í‚¤ì— ê¸°ë°˜í•œ ì„œë²„ ì¸ì¦ì„œë¥¼ ìƒì„±í•´ì•¼í•œë‹¤.
```bash
openssl req -new -key server.key -days 3650 -out server.crt -x509 -subj '/C=KR/ST=Seoul/L=Seoul/O=Somansa/CN=somansa.com/emailAddress=bluetomorrow@somansa.com'
```

1.5. ìš°ë¦¬ëŠ” ì§ì ‘ ì¸ì¦ì„œë¥¼ ì„œëª…í•  ê²ƒì´ë¯€ë¡œ ìƒì„±ëœ ì„œë²„ ì¸ì¦ì„œëŠ” ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë£¨íŠ¸ ì¸ì¦ì„œë¡œë„ ì‚¬ìš©ë  ìˆ˜ ìˆë‹¤. ì ì ˆí•œ ì´ë¦„ìœ¼ë¡œ ì„œë²„ ì¸ì¦ì„œë¥¼ ë³µì‚¬í•˜ì.
```bash
cp server.crt root.crt
```

1.6. ì´ì œ ë‹¹ì‹ ì€ 3ê°€ì§€ì˜ ì¸ì¦ì„œ íŒŒì¼ì„ ëª¨ë‘ ê°€ì§€ê³  ìˆê¸°ë•Œë¬¸ì— SSLì„ í™œì„±í™”í•˜ê³  ì‚¬ìš©í•˜ê¸° ìœ„í•œ PostgreSQL ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •ì„ ìˆ˜í–‰í•  ìˆ˜ ìˆë‹¤. ë¨¼ì € pg_hba.conf íŒŒì¼ì„ ì—´ì–´ ì•„ë˜ì™€ ê°™ì´ ìˆ˜ì •í•œë‹¤.
```bash
# TYPE  DATABASE    USER        CIDR-ADDRESS          METHOD
# "local" is for Unix domain socket connections only
local   all         all                               trust
# IPv4 local connections:
hostssl all         all         127.0.0.1/32          md5 clientcert=1

# IPv4 remote connections for authenticated users
hostssl all         all         0.0.0.0/0             md5 clientcert=1
```

1.7. ë‹¤ìŒì€ postgresql.conf íŒŒì¼ì„ ì—´ì–´ ì•„ë˜ì™€ ê°™ì´ ìˆ˜ì •í•œë‹¤.
```bash
ssl = on
ssl_ca_file = 'root.crt'
```

1.8. ë§ˆì§€ë§‰ìœ¼ë¡œ PostgreSQL ì„œë¹„ìŠ¤ë¥¼ ì¬ì‹œì‘í•œë‹¤.
```bash
systemctl restart postgresql-11.service
```

**2. í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ì„œ**
2.1. ìœ„ì—ì„œ ì‘ì—…í–ˆë˜ ì„œë²„ ì¸ì¦ì„œê°€ ì•ìœ¼ë¡œì˜ ì‘ì—…ì— í•„ìš”í•˜ê¸° ë•Œë¬¸ì— ì„œë²„ì™€ì˜ SSH ì ‘ì†ì„ ìœ ì§€í•˜ê³ , ìƒì„±í•  í´ë¼ì´ì–¸íŠ¸ì˜ ê°œì¸í‚¤ë¥¼ /tmp ê²½ë¡œì— ì„ì‹œ ì €ì¥í•œë‹¤.
```bash
openssl genrsa -des3 -out /tmp/postgresql.key 1024
openssl rsa -in /tmp/postgresql.key -out /tmp/postgresql.key
```

2.2. ë‹¤ìŒìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ ì¸ì¦ì„œë¥¼ ìƒì„±í•˜ê³  ê·¸ê²ƒì„ ìœ„ì—ì„œ ìƒì„±í–ˆë˜ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë£¨íŠ¸ ì¸ì¦ì„œ(root.crt)ë¡œ ì„œëª…í•œë‹¤.
```bash
openssl req -new -key /tmp/postgresql.key -out /tmp/postgresql.csr -subj '/C=KR/ST=Seoul/L=Seoul/O=Somansa/CN=postgres'
openssl x509 -req -in /tmp/postgresql.csr -CA root.crt -CAkey server.key -out /tmp/postgresql.crt -CAcreateserial
```

ğŸ’¡ Common Name(/CN=) ì€ ë°˜ë“œì‹œ pg_hba.conf íŒŒì¼ì—ì„œ ì‚¬ìš©í•œ USER ì´ë¦„ê³¼ ë™ì¼í•œ ì´ë¦„ì„ ì‚¬ìš©í•´ì•¼í•œë‹¤.<br>
ğŸ’¡ ë‘ë²ˆì§¸ ëª…ë ¹ì–´ì— ë³´ì´ëŠ” root.crtì™€ server.key íŒŒì¼ì€ ë°˜ë“œì‹œ ì „ì²´ ê²½ë¡œë¥¼ ëª…ì‹œí•´ ì£¼ì–´ì•¼í•œë‹¤. ìœ„ì˜ ê²½ìš°ì—ëŠ” í•´ë‹¹ íŒŒì¼ë“¤ì´ ì¡´ì¬í•˜ëŠ” ê²½ë¡œì—ì„œ ëª…ë ¹ì–´ë¥¼ ìˆ˜í–‰í–ˆê¸°ë•Œë¬¸ì— ì´ë¦„ë§Œ ì ì–´ë„ ë¬´ë°©í•˜ë‹¤.

2.3. postgresql.key, postgresql.crt, root.crt ì´ 3ê°œì˜ íŒŒì¼ì´ ì¤€ë¹„ê°€ ëë‹¤ë©´, ë‹¹ì‹ ì˜ í´ë¼ì´ì–¸íŠ¸ ë¨¸ì‹ ì˜ .postgresql í´ë”ì— ì´ íŒŒì¼ë“¤ì„ ì´ë™ì‹œì¼œì¤€ë‹¤. ë˜í•œ ì¢€ ë” ë‚˜ì€ ë³´ì•ˆì´ í•„ìš”í•˜ë‹¤ë©´ postgresql.key íŒŒì¼ì˜ ê¶Œí•œì„ 400ìœ¼ë¡œ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.
```bash
chmod 400 postgresql.key
```

ğŸ’¡ PostgreSQL ì„œë²„ì˜ /tmp ê²½ë¡œì— ìƒì„±í•´ë‘” ì¸ì¦ì„œ íŒŒì¼ë“¤ì€ ë°˜ë“œì‹œ ì‚­ì œí•´ì£¼ì!

<br>